<!DOCTYPE html>
<html>
<head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-inline-code {
        background-color: #DCDCC6;
        padding: .2em .4em;
        font-size: 90%;
      }

      .footnote {
        position: absolute;
        bottom: 3em;
      }
      code {
        border-radius: 5px;
      }
    </style>
</head>
<body>
<textarea id="source">

class: center, middle

# Scala for beginners

.footnote[[github.com/vdebergue/scala-beginner](https://github.com/vdebergue/scala-beginner)]
---

# Agenda

1. Introduction
2. Start programming
3. Basics
4. Standard Library
5. ...

---

# Introduction
## Why Scala ?
--

> A problem well put is half solved.

John Dewey

<br>
> A scalable programming language is one in which the same concepts can describe small as well as large parts.

Martin Odersky

---
# In a few words

- Scala is a **general purpose** programming language

- Scala is **object oriented**

- Scala is **statically typed**

- Scala enables both **functional programming** and **imperative programming**

---
class: center, middle

# 2. Start programming

---
# Start programming
## Hello world

```scala
object HelloWorld extends App {
  println("Hello world")
}
```

.footnote[`a_hello/A_HelloWorld.scala`]

---
## Running a scala program

- Install [sbt](https://www.scala-sbt.org/)

- Start sbt from root folder of this repo

- Run your main class:

```text
% sbt
sbt:scala-beginner> runMain a_hello.A_HelloWorld
```

_ tab autocompletion works with sbt _

---
## Using the REPL

```text
sbt> console
[info] Starting scala interpreter...
Welcome to Scala 2.12.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_162).
Type in expressions for evaluation. Or try :help.

scala> println("hello !")
hello !

scala> 1+1
res1: Int = 2
```

---
## Scala flexible syntax

```
"The 'Hello world' string" should {
  "contain 11 characters" in {
    "Hello world" must have size (11)
  }
}
```

```
class PingPong extends Actor {
  def receive = {
    case x => sender ! x
  }
}
```

```
class ExprParser extends RegexParsers {
  def factor = "[0-9]+".r | "("~expr~")"
  def term = factor~("*" | "/")~factor
  def expr = term~("+" | "-")~term
}
```

---
class: center, middle

# 3. Basics

---
# Basics

```
val x = 32

val y = x + 10

val name = "Scala"

var i = 0
i = 1

def lesson = "Values and types"
```

- `val` for value == imutable reference

- `var` for variable == mutable reference

- `def` for definition == evaluated each time it's called

.footnote[_b_basics/A_Values.scala_]

---
# Values and types

Type is infered by the compiler but it can also be supplied

```
val x: Int = 32

val name: String = "Scala"

def lesson: String = "Types"

def hello(to: String) = println(s"Hello $to !")
```
.footnote[_b_basics/B_Types.scala_]

---
# Common types

Numeric:
- `Int` : 32 bits signed integer
- `Long`: 64 bits signed integer
- `Float` : 32 bits floating point
- `Double`: 64 bits floating point

Other:
- `Boolean`: `true` or `false`
- `String`

---
# Method calls

```
"Hello World".size
```

- Methods are applied on values using the **dot notation**

```
1.to(10)
```

.footnote[_b_basics/C_Methods.scala_]

--

- Infix syntax can be used

```
1 to 10
```

---
# Operators are just methods

```
1 + 3 == 1.+(3)

"Hello " + "world" == "Hello ".+("world")
```

The unification of methods and operators makes the language simplier

.footnote[_b_basics/D_Operators.scala_]

---
# Exercise

- Use the methods `abs` to get the absolute value of `-42`

- Use `toUpperCase` to upper case your name

---
# Types guide you

- Types forbid you to combine values in a wrong way

```text
scala> 1 to "10"
1 to "10"
<console>:12: error: type mismatch;
 found   : String("10")
 required: Int
       1 to "10"
            ^
```

---
# Functions

Functions are expressions that take parameters.

```
val addOne = (x: Int) => x + 1
println(addOne(1)) // 2
```

On the left of `=>` is a list of parameters. On the right is an expression involving the parameters.

Functions may take multiple parameters

```
val add = (x: Int, y: Int) => x + y
println(add(1, 2)) // 3
```
---
# Methods

```
def add(x: Int, y: Int): Int = x + y

// multi parameters list
def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier

// no parameters
def name: String = System.getProperty("user.name")

// multiline
def getSquareString(input: Double): String = {
  val square = input * input
  square.toString
}
```

The last expression of a block is returned.

_Pro Tips:_ Avoid using `return`

---
# Classes

```
class Greeter(prefix: String) {
  def greet(name: String): Unit = {
    println(s"Hello $prefix $name")
  }
}

val greeter = new Greeter("little")
greeter.greet("world") // Hello little world
```

- You use the `class` keyword to define a class.

- A class can be instantiated with the `new` keyword

---
# Case classess

A `case class` is a special class. By default they are immutable

```
case class Point(x: Int, y: Int)

val point = Point(10, 10)
val otherPoint = Point(10, 10)

println(point) // Point(10,10)
point == otherPoint // true
```

---
# Objects

Objects are single instances of their own definitions. You can think of them as singletons of their own classes.

You can define objects with the object keyword.

```
object IdFactory {
  private var counter = 0
  def create(): Int = {
    counter += 1
    counter
  }
}
```

```
val newId: Int = IdFactory.create()
println(newId) // 1
val newerId: Int = IdFactory.create()
println(newerId) // 2
```

---
# Traits

```
trait WithSize {
  def size: Int // abstract method
  def isEmpty: Boolean = size == 0 // method with default implementation
}
```

```
case class Classroom(nbStudents: Int) extends WithSize {
  def size = nbStudents
}

val scalaClassroom = Classroom(32)
scalaClassroom.isEmpty // false
```

---
# Sealed trait

A sealed trait is a trait where **all sub classes** are defined in the **same file**

```
sealed trait SchoolPersonnel { def name: String }

case class Student(name: String) extends SchoolPersonnel
case class Teacher(name: String, subject: String) extends SchoolPersonnel
```

--
Enum example
```
sealed trait Weekday
case object Monday extends Weekday
case object Tuesday extends Weekday
case object Wednesday extends Weekday
...
```

---
# Modeling the world

The combination of `sealed trait` and `case class` gives a convenient way to model information in terms of **is** and **has** relationships

--
- A line is ego-left or ego-right:

    - `Line` _sealed trait_ extended by `EgoLeft` and `EgoRight`

- A car has a color and a position

    - `Car` _case class_ has `color` and `position` members

---
# Exercise

Model the following domain in Scala:

- A course has a name and a difficulty level
- A difficulty level is either “beginner”, “intermediate” or “advanced”

Can you then define a course named “Programming in Scala” targetting beginners?

---
# Control Flow

```
val name = "Scala lessons"
val greatness = if (name.contains("Scala")) {
  "Awesome"
} else {
  "Regular"
}
```

```
var i = 0
while(i < 10) {
  println(s"Count is $i")
  i += 1
}
```

---
# Pattern matching

Syntax:
```
val x: Int = scala.util.Random.nextInt(10)
val howMany = x match {
  case 0 => "zero"
  case 1 => "one"
  case 2 => "two"
  case _ => "many"
}

println(s"Value $x is $howMany")
```

---
# Pattern matching on case class

```
sealed trait Shape
case class Rectangle(width: Int, height: Int) extends Shape
case class Triangle(width: Int, height: Int) extends Shape
case class Circle(radius: Int) extends Shape
```

```
def showShape(shape: Shape) = shape match {
  case Rectangle(w, h) => s"Rectangle of width=$w and height=$h"
  case Triangle(w, h) => s"Triangle of width=$w and height=$h"
  case Circle(r) => s"Circle of radius=$r"
}

println(showShape(Circle(10)))
```

---
# Pattern matching

- With guard

```
def isSquare(shape: Shape): Boolean = shape match {
  case Rectangle(w, h) if w == h => true
  case _ => false
}
```

- On type

```
def showShape(shape: Shape) = shape match {
  case r: Rectangle => s"Rectangle of width=${r.width} and height=${r.height}"
  case t: Triangle => s"Triangle of width=${t.width} and height=${t.height}"
  case Circle(r) => s"Circle of radius=$r"
}
```

_This is the same as `isInstanceOf`_

---
# Exercise

Define a function that takes a course in input and returns a grade:

- if the name of the course contains "Scala" returns a 10
- if the difficulty is low, returns a 8
- if the difficulty is high but the name contains "Python" returns a 9
- else returs a 5

---
class: center, middle

# 4. Standard Library

---
# Option

```
sealed trait Option[A]
case class Some[A](value: A) extends Option[A]
case object None extends Option[Nothing]
```

```
Seq.empty[String].headOption
Seq("foo", "bar").headOption

Map("foo" -> 1, "bar").get("foo")
```

---
# Option

How to deal with them ?

--
- Pattern Matching

```
val opt = Option(3)
opt match {
  case Some(x) => println(s"Got value $x")
  case None => println("No value :(")
}
```
--
- Functional construct

```
val opt = Option(3)
opt.fold(println("No value :("))(x => println("Got value $x"))

// see also .map, .flatMap, .filter, .getOrElse
```

---
# Either

Used to represent a value that can be type `A` or `B`

Eg.: The return of an api call is an error or a String:

```
def getResultFromServer(): Either[Error, Int] = ???

val result = getResultFromServer()

result match {
  case Right(x) => println(s"server result is $x")
  case Left(error) => println(s"Got error when getting result: $error")
}
```
--
When dealing with errors, by convention the left type represents the error and the right type the value.

Due to that, `Either` is _right-biased_: `.map`, `.filter` functions will apply on the right type

```
val doubleResult: Either[Error, Int] = result.map(x => x * 2)
```

---
# Exercise

- Create a function `makeEasier` that takes a `Course` as input and returns a new course with a lower difficulty level.
If the difficulty is already the lowest, returns a None

- Create a function `makeForNoobs` that takes a `Course` as input and makes it twice easier

---
# Standard Collection

`scala.collection`

.center[![scala.collection](https://docs.scala-lang.org/resources/images/tour/collections-diagram.svg)]

---
background-image: url(https://docs.scala-lang.org/resources/images/tour/collections-immutable-diagram.svg)

# Standard Collection

`scala.collection.immutable`

---
background-image: url(https://docs.scala-lang.org/resources/images/tour/collections-mutable-diagram.svg)
background-size: 100%

# Standard Collection

`scala.collection.mutable`

---
# Standard Collection Overview

```
Traversable(1, 2, 3)
Iterable("x", "y", "z")
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(Color.red, Color.green, Color.blue)
SortedSet("hello", "world")
Buffer(x, y, z)
IndexedSeq(1.0, 2.0)
LinearSeq(a, b, c)

// Specific implems
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)
```

---
# Seq, List, Vector

```
val xs = Seq(1, 2, 3)

xs(0) // 1
xs(10) // throw Exception
xs.length // 3

xs.map(x => x + 1) // Seq(2, 3, 4)
xs.filter(x => x > 1) // Seq(2, 3)
val (evens, ods) = xs.span(x => x % 2 == 0) // (Seq(2), Seq(1, 3))

List(1, 2, 3)
Vector(1, 2, 3)
```

---
# Map

```
val capitals = Map(
  "France" -> "Paris",
  "USA" -> "Washington",
  "China" -> "Beijing"
)

capitals("France") // "Paris"
capitals.get("France") // Some("Paris")
capitals.get("Argentina") // None

capitals.getOrElse("Argentina", "Unknown")

val updated = capitals ++ Map("Argentina" -> "Buenos Aires")
```

---
# Set

```
val colors = Set("red", "green", "blue")

colors.contains("red")
colors.contains("white")

colors intersect Set("red", "white")
colors union Set("red", "white")
colors diff Set("red", "white")
```

---
# Exercise

Create a class `CourseCatalog` that contains a catalog of `Course`. On this `CourseCatalog` a user should be able to:

  - `listByDifficulty(difficulty)`: get the list of `Course` according to a difficulty

  - `search(query)`: get the list of `Course` where the name contains the user query

  - `getNames`: get the names of all the courses

  - `getStats`: returns the number of course by difficulty: `beginner -> 3, intermediate -> 2, advanced -> 4`

---
# For comprehension

```
val image: Image = ???
val pixels: Seq[Pixel] = (0 until image.width).flatMap { x =>
  (0 until image.height).map { y =>
    Pixel(x, y)
  }
}
```
--
This can be rewritten as

```
val pixels = for {
  x <- 0 until image.width
  y <- 0 until image.height
} yield Pixel(x, y)
```

---
# For comprehension

for comprehension are just syntatic sugar. The compiler will translate them to `.map` `.flatMap`

They work on all types that define a `.map` `flatMap`

```
def getServerResult(): Either[Error, Int] = ???
def runCalculation(input: Int): Either[Error, Calculation] = ???
def storeCalculation(calc: Calculation): Either[Error, Id] = ???

val storageId = for {
  result <- getServerResult()
  calculation <- runCalculation(result)
  id <- storeCalculation(calculation)
} yield id

storageId // Either[Error, Id]
```

</textarea>

<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
      var slideshow = remark.create({
        "highlightLanguage": "scala",
        "highlightStyle": "solarized-dark",
        "highlightLines": true
      });
    </script>
</body>
</html>
